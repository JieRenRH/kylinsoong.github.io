---
layout: blog
title:  "Understanding Teiid Engine"
date:   2015-05-25 17:00:00
categories: teiid
permalink: /teiid-dqp
author: Kylin Soong
duoshuoid: ksoong2015052501
excerpt: What is a Request, How Teiid DQPCore execute Reuqest.
---

* Table of contents
{:toc}

## DQP Process Request

Once the client SQL query be passed to Teiid Engine(DQPCore), it first be formed as a `org.teiid.dqp.internal.process.Request` Object, which is the Server side representation of the RequestMessage, the UML diagram of Request:

![Request UML]({{ site.baseurl }}/assets/blog/teiid-dqp-process-request.png)

* `processRequest()` is the key operation method, which invoked by RequestWorkItem.
* `TempTableStore` - TempTableStores are transanctional, but do not act as full resource manager. This means we are effectively 1PC and don't allow any heuristic exceptions on commit. Table state snapshoting and a `javax.transaction.Synchronization` are used to perform the appropriate commit/rollback actions.

> NOTE: refer to [link](http://ksoong.org/javaee/2016/01/20/jta-api-examples/#synchronization) for more about JTA Synchronization.

* `QueryMetadataInterface` - UML diagram refer to [link](http://ksoong.org/teiid-uml-diagram/#orgteiidquerymetadataquerymetadatainterface), refer to **Metadata Load Example** below for more details.
* `ProcessorDataManager` - UML diagram refer to [link](http://ksoong.org/teiid-uml-diagram/#orgteiidqueryprocessorprocessordatamanager)

## Metadata

### System Metadata 

Each time a VDB is uping, `org.teiid.query.metadata.SystemMetadata` will load the system etadata in advance, with the following sequence:

1. [types.dat](https://raw.githubusercontent.com/teiid/teiid/master/engine/src/main/resources/org/teiid/metadata/types.dat) - define all supported datatypes
2. [SYS.sql](https://raw.githubusercontent.com/teiid/teiid/master/engine/src/main/resources/org/teiid/metadata/SYS.sql) - Contain **System Tables:** Columns, DataTypes, KeyColumns, Keys, ProcedureParams, Procedures, FunctionParams, Functions, Properties, ReferenceKeyColumns, Schemas, Tables, VirtualDatabases; **System Procedures:** getXMLSchemas, ARRAYITERATE; **System Views:** spatial_ref_sys, GEOMETRY_COLUMNS
3. [SYSADMIN.sql](https://raw.githubusercontent.com/teiid/teiid/master/engine/src/main/resources/org/teiid/metadata/SYSADMIN.sql) - Contain **Tables:** Usage, MatViews, VDBResources, Triggers, Views, StoredProcedures; **Procedures:** isLoggable, logMsg, refreshMatView, refreshMatViewRow, refreshMatViewRows, setColumnStats, setProperty, setTableStats, matViewStatus, loadMatView, updateMatView 

### Metadata Load Example

`customer.ddl` under classpath, this example demonstrates how to load metadata in `customer.ddl`, with `QueryMetadataInterface`, the sample code looks as below:

~~~java
VDBMetaData vdb = new VDBMetaData();
vdb.setName("ExampleVDB");
vdb.setVersion(1);
Properties p = new Properties();
QueryParser parser = new QueryParser();
        
Map<String, Datatype> typeMap = SystemMetadata.getInstance().getRuntimeTypeMap();
        
ModelMetaData mmd = new ModelMetaData();
mmd.setName("ExampleMode");
vdb.addModel(mmd);
MetadataFactory factory = new MetadataFactory(vdb.getName(), vdb.getVersion(), "ExampleMode", typeMap, p, null);
parser.parseDDL(factory, loadReader("customer.ddl"));
MetadataStore systemStore = factory.asMetadataStore();
     
TransformationMetadata tm = new TransformationMetadata(vdb, new CompositeMetadataStore(systemStore), null, new SystemFunctionManager(typeMap).getSystemFunctions(), null);
vdb.addAttchment(QueryMetadataInterface.class, tm);
MetadataValidator validator = new MetadataValidator(typeMap, parser);
ValidatorReport report = validator.validate(vdb, systemStore);
if (report.hasItems()) {
   throw new TeiidRuntimeException(report.getFailureMessage());
}
~~~

## Process of generate a ProcessorPlan

![Pre generate ProcessorPlan]({{ site.baseurl }}/assets/blog/teiid-seq-pregeneratePlan.png)

As above figure, assuming a JDBC client execute SQL

~~~sql
SELECT ID, SYMBOL, COMPANY_NAME FROM Product
~~~

When the query engine receives an incoming SQL query, it be processed to Request's generatePlan() method, this methos will create a ProcessorPlan([UML diagram](http://ksoong.org/teiid-uml-diagram#orgteiidqueryprocessorprocessorplan)), which is a set of instructions created by a query engine for executing a command submitted by a user or application. The purpose of the query plan is to execute the userâ€™s query in as efficient a way as possible.

In this section, we will focus on the process if generate a ProcessorPlan, it performs the following operations:

### **1. Parsing** - validate SQL syntax and convert to internal form. 

SQL come from `RequestMessage` which transited from Client. ThreadLocal QueryParser has a parseCommand() method, which can parse SQL String to internal form, eg, `org.teiid.query.sql.lang.Command`, refer to [link](http://ksoong.org/teiid-query-sql-api) for more forms.

> NOTE: QueryParser has a javacc [SQLParser.jj](https://raw.githubusercontent.com/teiid/teiid/master/engine/src/main/javacc/org/teiid/query/parser/SQLParser.jj) based SQLParser, the parse result is a Command Object.

### **2. Resolving** - link all identifiers to metadata and functions to the function library

The `QueryResolver` is used between Parsing and QueryValidation, 

~~~java
QueryResolver.resolveCommand(command, metadata);
~~~

QueryResolver contains a series of `CommandResolver`([UML](http://ksoong.org/teiid-uml-diagram#orgteiidqueryresolvercommandresolver)) which used to implement Resolver by SQL Types(queries, inserts, updates and deletes).

after resolving, the format of command looks like

~~~sql
SELECT Accounts.PRODUCT.ID, Accounts.PRODUCT.SYMBOL, Accounts.PRODUCT.COMPANY_NAME FROM Accounts.PRODUCT
~~~

### **3. Validating** - validate SQL semantics based on metadata references and type signatures.

~~~java
AbstractValidationVisitor visitor = new ValidationVisitor();
ValidatorReport report = Validator.validate(command, metadata, visitor);
~~~

A `org.teiid.query.validator.ValidationVisitor` is used in Validating, ValidatorReport contain result of Validating.

### **4. Rewriting** - rewrite SQL to simplify expressions and criteria

`QueryRewriter` is used, 

~~~java
QueryRewriter.rewrite(command, metadata, context);
~~~

The aim of Rewriting is rewrite commands and command fragments to a form that is better for planning and execution. For example, language object From's clauses list not setted by default, Rewriting will do it.

### **5. Optimizing** - the rewritten canonical SQL is converted into a logical plan for in-depth optimization.

![generate ProcessorPlan]({{ site.baseurl }}/assets/blog/teiid-seq-generatePlan.png)

As figure, QueryOptimizer's optimizePlan() method is the entrence of Optimizing, the main of Optimizing has three primary phases:

1. Generate canonical plan
2. Optimization
3. Plan to process converter - converts plan data structure into a processing form

#### Generate canonical plan

This step will convert internal [Command](http://ksoong.org/teiid-query-sql-api) to a `PlanNode`.

With sql `SELECT ID, SYMBOL, COMPANY_NAME FROM Product`, the relevant Canonical Plan like

~~~java
Project(groups=[Accounts.PRODUCT], props={PROJECT_COLS=[Accounts.PRODUCT.ID, Accounts.PRODUCT.SYMBOL, Accounts.PRODUCT.COMPANY_NAME]})
  Source(groups=[Accounts.PRODUCT])
~~~

If Show Plan and Debug level logging be enabled, Generate canonical plan log can be found like

![canonical plan]({{ site.baseurl }}/assets/blog/teiid-plan-canonicalplan.png)

#### Optimization


#### Plan to process converter


 produces a ProcessorPlan object (a plan for query execution) from a user's command and a source of metadata.

* `org.teiid.query.optimizer.relational.RelationalPlanner` generates a relational plan for query execution. The output of this class is a `PlanNode`(refer to below **PlanNode** for details) - this object then becomes the input to `PlanToProcessConverter` to to  produce a `RelationalPlan`, more details refer to below sequence diagram.


### PlanNode

PlanNode come from SQL Command, this Object be convert to ProcessorPlan([UML diagram](http://ksoong.org/teiid-uml-diagram#orgteiidqueryprocessorprocessorplan)) via a PlanToProcessConverter, eg:

~~~java
PlanToProcessConverter planToProcessConverter = new PlanToProcessConverter(metadata, idGenerator, analysisRecord, capFinder, context);
PlanNode plan = generatePlan(command);
RelationalPlan result = planToProcessConverter.convert(plan);
~~~

Once a SQL command be Resolving, Validating and Rewriting, this command will be converted into logical plan, the Process of forming PlanNode:


**2. RuleStack**

* RuleStack - A stack which contain a series of Rules, each rules implement `org.teiid.query.optimizer.relational.OptimizerRule`,

[UML of Rules](http://ksoong.org/teiid-uml-diagram#orgteiidqueryoptimizerrelationaloptimizerrule)

From UML diagram, since Teiid 8.13, there are 28 rules existed. But in a very simple mode, by default only 6 rules be push to statck: RuleCollapseSource, RulePlanSorts, RuleCalculateCost, RuleAssignOutputElements, RuleRaiseAccess, RulePlaceAccess.

* EXECUTING PlaceAccess - implementation class is `org.teiid.query.optimizer.relational.rules.RulePlaceAccess`, this rule used to find all SOURCE nodes and associates ACCESS patterns, ACCESS nodes, and aliases. EXECUTING PlaceAccess log looks

![EXECUTING PlaceAccess]({{ site.baseurl }}/assets/blog/teiid-plan-planaccess.png)

* EXECUTING RaiseAccess - implementation class is `org.teiid.query.optimizer.relational.rules.RuleRaiseAccess`.

![EXECUTING RaiseAccess log]({{ site.baseurl }}/assets/blog/teiid-plan-raiseaccess.png)

* EXECUTING AssignOutputElements - implementation class is `org.teiid.query.optimizer.relational.rules.RuleAssignOutputElements`. This rule is responsible for assigning the output elements to every node in the plan. The output elements define the columns that are returned from every node. This is generally done by figuring out top-down all the elements required to execute the operation at each node and making sure those elements are selected from the children nodes.

![EXECUTING AssignOutputElements log]({{ site.baseurl }}/assets/blog/teiid-plan-AssignOutputElements.png)

* EXECUTING CalculateCost - implementation class is `org.teiid.query.optimizer.relational.rules.RuleCalculateCost`.

![EXECUTING CalculateCost log]({{ site.baseurl }}/assets/blog/teiid-plan-CalculateCost.png)

* EXECUTING PlanSorts - implementation class is `org.teiid.query.optimizer.relational.rules.RulePlanSorts`, attempts to minimize the cost of sorting operations across the plan.

![EXECUTING PlanSorts log]({{ site.baseurl }}/assets/blog/teiid-plan-PlanSorts.png)

* EXECUTING CollapseSource - implementation class is `org.teiid.query.optimizer.relational.rules.RuleCollapseSource`.

![EXECUTING CollapseSource log]({{ site.baseurl }}/assets/blog/teiid-plan-CollapseSource.png)

## RequestWorkItem run

RequestWorkItem class UML diagram can be find from [http://ksoong.org/teiid-uml-diagram/](http://ksoong.org/teiid-uml-diagram), RequestWorkItem implements `Runnable` interface, the flowchart of RequestWorkItem as below:

![RequestWorkItem run]({{ site.baseurl }}/assets/blog/teiid-requestWorkItem-run.png)
